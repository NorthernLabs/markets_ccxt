<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\alephx as Exchange;
use ccxt\ExchangeError;
use ccxt\BadRequest;
use ccxt\OrderNotFound;
use React\Async;
use React\Promise\PromiseInterface;

class alephx extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'alephx',
            'name' => 'AlephX',
            'countries' => array( 'CA' ),
            'pro' => true,
            'certified' => false,
            // rate-limits => N/A
            'rateLimit' => 1000,
            'version' => 'v1',
            'userAgent' => $this->userAgents['chrome'],
            // 'headers' => array(
            //     'ZKX-VERSION' => '2018-05-30',
            // ),
            'has' => array(
                'CORS' => true,
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'closeAllPositions' => false,
                'closePosition' => true,
                'createConvertTrade' => true,
                'createDepositAddress' => true,
                'createLimitBuyOrder' => true,
                'createLimitSellOrder' => true,
                'createMarketBuyOrder' => true,
                'createMarketBuyOrderWithCost' => true,
                'createMarketOrderWithCost' => false,
                'createMarketSellOrder' => true,
                'createMarketSellOrderWithCost' => false,
                'createOrder' => true,
                'createPostOnlyOrder' => true,
                'createReduceOnlyOrder' => false,
                'createStopLimitOrder' => true,
                'createStopMarketOrder' => false,
                'createStopOrder' => true,
                'deposit' => true,
                'editOrder' => true,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchBidsAsks' => true,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchCanceledOrders' => true,
                'fetchClosedOrders' => true,
                'fetchConvertQuote' => true,
                'fetchConvertTrade' => true,
                'fetchConvertTradeHistory' => false,
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => true,
                'fetchDeposit' => true,
                'fetchDepositAddress' => 'emulated',
                'fetchDepositAddresses' => false,
                'fetchDepositAddressesByNetwork' => true,
                'fetchDeposits' => true,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchL2OrderBook' => false,
                'fetchLedger' => true,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => false,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyBuys' => true,
                'fetchMySells' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchPosition' => true,
                'fetchPositionMode' => false,
                'fetchPositions' => true,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => 'emulated',
                'fetchTradingFees' => true,
                'fetchWithdrawals' => true,
                'reduceMargin' => false,
                'setLeverage' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'withdraw' => true,
            ),
            'urls' => array(
                // 'logo' => 'https://user-images.githubusercontent.com/1294454/40811661-b6eceae2-653a-11e8-829e-10bfadb078cf.jpg',
                'api' => array(
                    'rest' => 'https://api.alephx.xyz',
                ),
                'www' => 'https://demo.alephx.xyz',
                // 'doc' => array(
                //     'https://developers.alephx.com/api/v2',
                //     'https://docs.cloud.alephx.com/advanced-trade/docs/welcome',
                // ),
                // 'fees' => array(
                //     'https://support.alephx.com/customer/portal/articles/2109597-buy-sell-bank-transfer-fees',
                //     'https://www.alephx.com/advanced-fees',
                // ),
                // 'referral' => 'https://www.alephx.com/join/58cbe25a355148797479dbd2',
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
            ),
            'api' => array(
                'v1' => array(
                    // 'public' => array(
                    // ),
                    'private' => array(
                        'get' => array(
                            'orders' => 0,
                            'orders/{id}' => 0,
                            'trades' => 0,
                        ),
                        'post' => array(
                            'orders' => 0,
                        ),
                        'patch' => array(
                            'orders/{id}/cancel' => 0,
                        ),
                    ),
                ),
            ),
            // 'fees' => array(
            // ),
            // 'precisionMode' => TICK_SIZE,
            // 'exceptions' => array(
            //     'exact' => array(
            //         'two_factor_required' => '\\ccxt\\AuthenticationError', // 402 When sending money over 2fa limit
            //         'param_required' => '\\ccxt\\ExchangeError', // 400 Missing parameter
            //         'validation_error' => '\\ccxt\\ExchangeError', // 400 Unable to validate POST/PUT
            //         'invalid_request' => '\\ccxt\\ExchangeError', // 400 Invalid request
            //         'personal_details_required' => '\\ccxt\\AuthenticationError', // 400 User’s personal detail required to complete this request
            //         'identity_verification_required' => '\\ccxt\\AuthenticationError', // 400 Identity verification is required to complete this request
            //         'jumio_verification_required' => '\\ccxt\\AuthenticationError', // 400 Document verification is required to complete this request
            //         'jumio_face_match_verification_required' => '\\ccxt\\AuthenticationError', // 400 Document verification including face match is required to complete this request
            //         'unverified_email' => '\\ccxt\\AuthenticationError', // 400 User has not verified their email
            //         'authentication_error' => '\\ccxt\\AuthenticationError', // 401 Invalid auth (generic)
            //         'invalid_authentication_method' => '\\ccxt\\AuthenticationError', // 401 API access is blocked for deleted users.
            //         'invalid_token' => '\\ccxt\\AuthenticationError', // 401 Invalid Oauth token
            //         'revoked_token' => '\\ccxt\\AuthenticationError', // 401 Revoked Oauth token
            //         'expired_token' => '\\ccxt\\AuthenticationError', // 401 Expired Oauth token
            //         'invalid_scope' => '\\ccxt\\AuthenticationError', // 403 User hasn’t authenticated necessary scope
            //         'not_found' => '\\ccxt\\ExchangeError', // 404 Resource not found
            //         'rate_limit_exceeded' => '\\ccxt\\RateLimitExceeded', // 429 Rate limit exceeded
            //         'internal_server_error' => '\\ccxt\\ExchangeError', // 500 Internal server error
            //         'UNSUPPORTED_ORDER_CONFIGURATION' => '\\ccxt\\BadRequest',
            //         'INSUFFICIENT_FUND' => '\\ccxt\\BadRequest',
            //         'PERMISSION_DENIED' => '\\ccxt\\PermissionDenied',
            //         'INVALID_ARGUMENT' => '\\ccxt\\BadRequest',
            //     ),
            //     'broad' => array(
            //         'request timestamp expired' => '\\ccxt\\InvalidNonce', // array("errors":[array("id":"authentication_error","message":"request timestamp expired")])
            //         'order with this orderID was not found' => '\\ccxt\\OrderNotFound', // array("error":"unknown","error_details":"order with this orderID was not found","message":"order with this orderID was not found")
            //     ),
            // ),
            // 'timeframes' => array(
            //     '1m' => 'ONE_MINUTE',
            //     '5m' => 'FIVE_MINUTE',
            //     '15m' => 'FIFTEEN_MINUTE',
            //     '30m' => 'THIRTY_MINUTE',
            //     '1h' => 'ONE_HOUR',
            //     '2h' => 'TWO_HOUR',
            //     '6h' => 'SIX_HOUR',
            //     '1d' => 'ONE_DAY',
            // ),
            // 'commonCurrencies' => array(
            //     'CGLD' => 'CELO',
            // ),
            // 'options' => array(
            //     'usePrivate' => false,
            //     'brokerId' => 'ccxt',
            //     'stablePairs' => array( 'BUSD-USD', 'CBETH-ETH', 'DAI-USD', 'GUSD-USD', 'GYEN-USD', 'PAX-USD', 'PAX-USDT', 'USDC-EUR', 'USDC-GBP', 'USDT-EUR', 'USDT-GBP', 'USDT-USD', 'USDT-USDC', 'WBTC-BTC' ),
            //     'fetchCurrencies' => array(
            //         'expires' => 5000,
            //     ),
            //     'accounts' => array(
            //         'wallet',
            //         'fiat',
            //         // 'vault',
            //     ),
            //     'v3Accounts' => array(
            //         'ACCOUNT_TYPE_CRYPTO',
            //         'ACCOUNT_TYPE_FIAT',
            //     ),
            //     'networks' => array(
            //         'ERC20' => 'ethereum',
            //         'XLM' => 'stellar',
            //     ),
            //     'createMarketBuyOrderRequiresPrice' => true,
            //     'advanced' => true, // set to true if using any v3 endpoints from the advanced trade API
            //     'fetchMarkets' => 'fetchMarketsV3', // 'fetchMarketsV3' or 'fetchMarketsV2'
            //     'fetchTicker' => 'fetchTickerV3', // 'fetchTickerV3' or 'fetchTickerV2'
            //     'fetchTickers' => 'fetchTickersV3', // 'fetchTickersV3' or 'fetchTickersV2'
            //     'fetchAccounts' => 'fetchAccountsV3', // 'fetchAccountsV3' or 'fetchAccountsV2'
            //     'fetchBalance' => 'v2PrivateGetAccounts', // 'v2PrivateGetAccounts' or 'v3PrivateGetBrokerageAccounts'
            //     'fetchTime' => 'v2PublicGetTime', // 'v2PublicGetTime' or 'v3PublicGetBrokerageTime'
            //     'user_native_currency' => 'USD', // needed to get fees for v3
            // ),
        ));
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create an order
             * @see POST https://api.alephx.xyz/api/v1/orders
             * @param {string} $symbol unified $symbol of the market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much you want to trade in units of the base currency, quote currency for 'market' 'buy' orders
             * @param {float} [$price] the $price to fulfill the order, in units of the quote currency, ignored in market orders
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {string} [$params->timeInForce] 'gtc'
             * @param {string} [$params->idempotencyKey] uuid for idempotency key
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            $request = array(
                'pair' => $symbol,
                'type' => $side,
                'ordertype' => $type,
                'volume' => $amount,
            );
            $orderRequest = $this->order_request('createOrder', $symbol, $type, $request, $amount, $price, $params);
            $response = Async\await($this->v1PrivatePostOrders ($this->extend($orderRequest[0], $orderRequest[1])));
            //
            // successful order
            //
            //
            // failed order
            //
            //
            $errorResponse = $this->safe_dict($response, 'error');
            if ($errorResponse !== null) {
                $errorReason = $this->safe_string($errorResponse, 'reason');
                $errorMessage = $this->safe_string($errorResponse, 'message');
                throw new ExchangeError($errorReason . '' . $errorMessage);
            }
            return $this->parse_order($response);
        }) ();
    }

    public function order_request(string $method, string $symbol, string $type, array $request, ?float $amount, ?float $price = null, $params = array ()) {
        $clientOrderId = $this->safe_string_2($params, 'idempotencyKey', 'idempotencykey');
        if ($clientOrderId !== null) {
            $request['idempotencyKey'] = $clientOrderId;
        }
        $isLimitOrder = $type === 'limit';
        if ($isLimitOrder) {
            $request['price'] = $price;
        }
        $timeInForce = $this->safe_string_2($params, 'timeInForce', 'gtc');
        if ($timeInForce !== null) {
            $request['timeinforce'] = $timeInForce;
        }
        $params = $this->omit($params, array( 'timeInForce', 'idempotencyKey' ));
        return array( $request, $params );
    }

    public function parse_order(array $order, ?array $market = null): array {
        //
        // createOrder
        //
        //     {
        //         "order_id" => "52cfe5e2-0b29-4c19-a245-a6a773de5030",
        //         "status" => "pending_new"
        //     }
        //
        // cancelOrder
        //
        //     {
        //     }
        //
        // fetchOrder, fetchOrders
        //
        //     {
        //     }
        //
        $createdDateTime = $this->safe_string($order, 'inserted_at');
        $filledDateTime = $this->safe_string($order, 'filled_at');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $this->safe_string($order, 'order_id') || $this->safe_string($order, 'id'),
            'clientOrderId' => $this->safe_string($order, 'idempotency_key'),
            'timestamp' => $createdDateTime ? $this->parse8601($createdDateTime) : null,
            'datetime' => $createdDateTime,
            'lastTradeTimestamp' => $filledDateTime ? $this->parse8601($filledDateTime) : null,
            'symbol' => $this->safe_string($order, 'symbol'),
            'type' => $this->safe_string($order, 'type'),
            'timeInForce' => $this->safe_string($order, 'time_in_force'),
            'postOnly' => true,
            'side' => $this->safe_string_lower($order, 'side'),
            'price' => $this->safe_string($order, 'price'),
            'stopPrice' => null,
            'triggerPrice' => null,
            'amount' => $this->safe_string($order, 'base_quantity'),
            'filled' => $this->safe_string($order, 'filled_quantity'),
            'remaining' => $this->safe_string($order, 'remained_quantity'),
            'cost' => null,
            'average' => $this->safe_string($order, 'average_filled_price'),
            'status' => $this->safe_string($order, 'status'),
            'fee' => array(
                'cost' => $this->safe_string($order, 'cumulative_fee'),
                'currency' => $this->safe_string($order, 'fee_asset'),
            ),
            'trades' => null,
        ), $market);
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open order
             * @see PATCH https://api.alephx.xyz/api/v1/orders/{order_id}/cancel
             * @param {string} $id order $id
             * @param {string} $symbol not used by alephx cancelOrder()
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            $request = array(
                'id' => $id, // order $id
            );
            $response = Async\await($this->v1PrivatePatchOrdersIdCancel ($this->extend($request, $params)));
            $errorResponse = $this->safe_dict($response, 'error');
            if ($errorResponse !== null) {
                $errorReason = $this->safe_string($errorResponse, 'reason');
                $errorMessage = $this->safe_string($errorResponse, 'message');
                if ($errorReason === 'Not Found') {
                    throw new OrderNotFound($this->id . ' cancelOrder() error ' . $errorReason);
                } elseif ($errorReason === 'Bad Request') {
                    throw new BadRequest($this->id . ' cancelOrder() error ' . $errorReason . ' ' . $errorMessage);
                } else {
                    throw new ExchangeError($errorReason . '' . $errorMessage);
                }
            }
            return $this->parse_order($response);
        }) ();
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an order made by the user
             * @see GET https://api.alephx.xyz/api/v1/orders/{order_id}
             * @param {string} $id the order $id
             * @param {string} $symbol unified market $symbol that the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            $request = array(
                'id' => $id, // order $id
            );
            $response = Async\await($this->v1PrivateGetOrdersId ($this->extend($request, $params)));
            $errorResponse = $this->safe_dict($response, 'error');
            if ($errorResponse !== null) {
                $errorReason = $this->safe_string($errorResponse, 'reason');
                if ($errorReason === 'Not Found') {
                    throw new OrderNotFound($this->id . ' fetchOrder() error ' . $errorReason);
                }
            }
            return $this->parse_order($response);
        }) ();
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = 100, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple orders made by the user
             * @see GET https://api.alephx.xyz/api/v1/orders/
             * @param {string} $symbol unified $market $symbol that the orders were made in
             * @param {int} [$since] the earliest time in ms to fetch orders
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} [$params->until] the latest time in ms to fetch trades for
             * @param {boolean} [$params->paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
             * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $request = array();
            $response = Async\await($this->v1PrivateGetOrders ($this->extend($request, $params)));
            //
            //
            $market = null;
            return $this->parse_orders($response, $market, $since, $limit);
        }) ();
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all trades made by the user
             * @see GET https://api.alephx.xyz/api/v1/trades
             * @param {string} $symbol unified $market $symbol of the trades
             * @param {int} [$since] timestamp in ms of the earliest order, default is null
             * @param {int} [$limit] the maximum number of trade structures to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {int} [$params->until] the latest time in ms to fetch trades for
             * @param {boolean} [$params->paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            $request = array();
            $response = Async\await($this->v1PrivateGetTrades ($this->extend($request, $params)));
            //
            //
            $market = null;
            return $this->parse_trades($response, $market, $since, $limit);
        }) ();
    }

    public function parse_trade(array $trade, ?array $market = null): array {
        // fetchTrades
        //
        //     {
        //     }
        //
        $createdDateTime = $this->safe_string($trade, 'inserted_at');
        $traderSide = $this->safe_string($trade, 'side');
        $traderOrderId = $traderSide === 'buy' ? $this->safe_string($trade, 'buy_order_id') : $this->safe_string($trade, 'sell_order_id');
        return $this->safe_trade(array(
            'id' => $this->safe_string($trade, 'id'),
            'order' => $traderOrderId,
            'info' => $trade,
            'timestamp' => $this->parse8601($createdDateTime),
            'datetime' => $createdDateTime,
            'symbol' => $this->safe_string($trade, 'symbol'),
            'type' => null,
            'side' => $traderSide,
            'takerOrMaker' => null,
            'price' => $this->safe_string($trade, 'price'),
            'amount' => $this->safe_string($trade, 'base_quantity'),
            'cost' => $this->safe_string($trade, 'quote_quantity'),
            'fee' => array(
                'cost' => $this->safe_string($trade, 'fee'),
                'currency' => $this->safe_string($trade, 'fee_asset'),
            ),
        ), $market);
    }

    public function sign($path, $api = [], $method = 'GET', $params = array (), $headers = null, $body = null) {
        $version = $api[0];
        $signed = $api[1] === 'private';
        $fullPath = '/api/' . $version . '/' . $this->implode_params($path, $params);
        $query = $this->omit($params, $this->extract_params($path));
        $savedPath = $fullPath;
        if ($method === 'GET') {
            if ($query) {
                $fullPath .= '?' . $this->urlencode_with_array_repeat($query);
            }
        }
        $url = $this->urls['api']['rest'] . $fullPath;
        if ($signed) {
            $authorization = $this->safe_string($this->headers, 'Authorization');
            $authorizationString = null;
            if ($authorization !== null) {
                $authorizationString = $authorization;
            } elseif ($this->token && !$this->check_required_credentials(false)) {
                $authorizationString = 'Bearer ' . $this->token;
            } else {
                $this->check_required_credentials();
                // doesn't need payload in the $signature-> inside $url is enough
                $timestampString = (string) $this->seconds();
                $auth = $timestampString . $method . $savedPath;
                $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256');
                $headers = array(
                    'ZKX-ACCESS-KEY' => $this->apiKey,
                    'ZKX-ACCESS-SIGN' => $signature,
                    'ZKX-ACCESS-TIMESTAMP' => $timestampString,
                    'Content-Type' => 'application/json',
                );
            }
            if ($authorizationString !== null) {
                $headers = array(
                    'Authorization' => $authorizationString,
                    'Content-Type' => 'application/json',
                );
                if ($method !== 'GET') {
                    if ($query) {
                        $body = $this->json($query);
                    }
                }
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors(int $code, string $reason, string $url, string $method, array $headers, string $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return null; // fallback to default error handler
        }
        $feedback = $this->id . ' ' . $body;
        //
        //
        //    {
        //      "error" => {
        //        {
        //          "reason" => "Bad Request",
        //          "message" => "Order is not cancellable"
        //        }
        //      }
        //    }
        //
        $errorResponse = $this->safe_dict($response, 'error');
        $errorCode = $this->safe_string($errorResponse, 'reason');
        if ($errorCode !== null) {
            $errorMessage = $this->safe_string($errorResponse, 'message');
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $errorMessage, $feedback);
            throw new ExchangeError($feedback);
        }
        // $errors = $this->safe_list($response, 'errors');
        // if ($errors !== null) {
        //     if (gettype($errors) === 'array' && array_keys($errors) === array_keys(array_keys($errors))) {
        //         $numErrors = count($errors);
        //         if ($numErrors > 0) {
        //             $errorCode = $this->safe_string($errors[0], 'id');
        //             $errorMessage = $this->safe_string($errors[0], 'message');
        //             if ($errorCode !== null) {
        //                 $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
        //                 $this->throw_broadly_matched_exception($this->exceptions['broad'], $errorMessage, $feedback);
        //                 throw new ExchangeError($feedback);
        //             }
        //         }
        //     }
        // }
        return null;
    }
}
