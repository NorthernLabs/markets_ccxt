<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use React\Async;
use React\Promise\PromiseInterface;

class alephx extends \ccxt\async\alephx {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'cancelAllOrdersWs' => false,
                'cancelOrdersWs' => false,
                'cancelOrderWs' => false,
                'createOrderWs' => false,
                'editOrderWs' => false,
                'fetchBalanceWs' => false,
                'fetchOpenOrdersWs' => false,
                'fetchOrderWs' => false,
                'fetchTradesWs' => false,
                'watchBalance' => false,
                'watchMyTrades' => true,
                'watchOHLCV' => false,
                'watchOrderBook' => false,
                'watchOrderBookForSymbols' => false,
                'watchOrders' => true,
                'watchTicker' => false,
                'watchTickers' => false,
                'watchTrades' => false,
                'watchTradesForSymbols' => false,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://api.alephx.xyz/websocket',
                ),
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'ordersLimit' => 1000,
                'myTradesLimit' => 1000,
                'sides' => array(
                    'bid' => 'bids',
                    'offer' => 'asks',
                ),
            ),
        ));
    }

    public function subscribe(string $name, bool $isPrivate, $symbol = null, $params = array ()) {
        return Async\async(function () use ($name, $isPrivate, $symbol, $params) {
            /**
             * @ignore
             * subscribes to a websocket channel
             * @see https://api.alephx.xyz/websocket
             * @param {string} $name the $name of the channel
             * @param {string|string[]} [$symbol] unified market $symbol
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} subscription to a websocket channel
             */
            $url = $this->urls['api']['ws'];
            $messageHash = $name;
            if ($isPrivate) {
                $auth = $this->create_ws_auth();
                $url = $url . '?api_key=' . $auth['api_key'] . '&timestamp=' . $auth['timestamp'] . '&signature=' . $auth['signature'];
                $messageHash = $messageHash . ':' . $auth['api_key'];
            }
            $subscribe = array(
                'event' => 'phx_join',
                'topic' => $messageHash,
                'payload' => array(),
                'ref' => $messageHash,
                'join_ref' => $messageHash,
            );
            return Async\await($this->watch($url, $messageHash, $subscribe, $messageHash));
        }) ();
    }

    public function create_ws_auth() {
        $subscribe = array();
        $timestamp = $this->number_to_string($this->seconds());
        $this->check_required_credentials();
        $auth = $timestamp;
        $subscribe['api_key'] = $this->apiKey;
        $subscribe['timestamp'] = $timestamp;
        $subscribe['signature'] = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256');
        return $subscribe;
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             * @see $trades channel
             * @param {string} $symbol unified $symbol of the market to fetch $trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of $trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            $name = 'trades';
            $trades = Async\await($this->subscribe($name, true, $symbol, $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @see $orders channel
             * @param {string} [$symbol] unified market $symbol of the market $orders were made in
             * @param {int} [$since] the earliest time in ms to fetch $orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
             */
            $name = 'orders';
            $orders = Async\await($this->subscribe($name, true, $symbol, $params));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($orders, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trade($client, $message) {
        // {
        //     ref => null,
        //     $payload => {
        //       timestamp => '2024-10-04T03:11:30.111216Z',
        //       channel => 'trades',
        //       $trade => array(
        //         symbol => 'CLEO-ALEO',
        //         price => '1.1',
        //         base_quantity => '0.1',
        //         quote_quantity => '0.11',
        //         buy_order_id => 'ad2066e6-a47c-449d-99be-79ac82e7d163',
        //         sell_order_id => '1676786b-145f-4dcf-adde-74e5cce9ebc3',
        //         status => 'unsettled',
        //         aggressor_side => 'sell',
        //         id => 'e0b8354a-d71a-4577-bee5-ce52d8fabcf5',
        //         fee => null,
        //         fee_asset => null
        //       }
        //     ),
        //     topic => 'trades:cb77b9ab-f94d-4013-85b7-644b0b9ba9a9',
        //     event => 'trades'
        //   }
        if ($this->myTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $this->myTrades = new ArrayCacheBySymbolById ($limit);
        }
        $payload = $this->safe_dict($message, 'payload');
        $trade = $this->safe_dict($payload, 'trade');
        $parsed = $this->parse_ws_trade($trade);
        $this->myTrades.append ($parsed);
        $messageHash = $this->safe_string($message, 'topic');
        $client->resolve ($this->myTrades, $messageHash);
        return $message;
    }

    public function parse_ws_trade($trade, $market = null) {
        //      {
        //         symbol => 'CLEO-ALEO',
        //         price => '1.1',
        //         base_quantity => '0.1',
        //         quote_quantity => '0.11',
        //         buy_order_id => 'ad2066e6-a47c-449d-99be-79ac82e7d163',
        //         sell_order_id => '1676786b-145f-4dcf-adde-74e5cce9ebc3',
        //         status => 'unsettled',
        //         aggressor_side => 'sell',
        //         id => 'e0b8354a-d71a-4577-bee5-ce52d8fabcf5',
        //         fee => null,
        //         fee_asset => null
        //       }
        $createdDateTime = $this->safe_string($trade, 'inserted_at');
        $traderSide = $this->safe_string($trade, 'side');
        $traderOrderId = $traderSide === 'buy' ? $this->safe_string($trade, 'buy_order_id') : $this->safe_string($trade, 'sell_order_id');
        return $this->safe_trade(array(
            'id' => $this->safe_string($trade, 'id'),
            'order' => $traderOrderId,
            'info' => $trade,
            'timestamp' => $this->parse8601($createdDateTime),
            'datetime' => $createdDateTime,
            'symbol' => $this->safe_string($trade, 'symbol'),
            'type' => 'gtc',
            'side' => $traderSide,
            'takerOrMaker' => null,
            'price' => $this->safe_string($trade, 'price'),
            'amount' => $this->safe_string($trade, 'base_quantity'),
            'cost' => $this->safe_string($trade, 'quote_quantity'),
            'fee' => array(
                'cost' => $this->safe_string($trade, 'fee'),
                'currency' => $this->safe_string($trade, 'fee_asset'),
            ),
        ), $market);
    }

    public function handle_order($client, $message) {
        // {
        //     ref => null,
        //     $payload => {
        //       timestamp => '2024-10-04T02:29:36.263148Z',
        //       channel => 'orders',
        //       $order => array(
        //         id => 'eed7ce96-f34b-483d-8d87-925eef6f0702',
        //         status => 'new',
        //         type => 'limit',
        //         symbol => 'CLEO-ALEO',
        //         inserted_at => '2024-10-04T02:29:35.693172Z',
        //         account_id => 'cb77b9ab-f94d-4013-85b7-644b0b9ba9a9',
        //         updated_at => '2024-10-04T02:29:36.254349Z',
        //         filled_quantity => '0',
        //         base_quantity => '0.1',
        //         idempotency_key => '99888999-93ef-9831-9829-820a082bfcf8',
        //         price => '1.1',
        //         remained_quantity => '0.1',
        //         side => 'buy',
        //         time_in_force => 'gtc',
        //         canceled_at => null,
        //         average_filled_price => null,
        //         canceled_quantity => '0',
        //         cumulative_fee => '0',
        //         fee_asset => null,
        //         filled_at => null,
        //         filled_value => '0',
        //         lock_version => 3,
        //         quote_quantity => null,
        //         sequence_id => 187,
        //         settled_quantity => '0'
        //       }
        //     ),
        //     topic => 'orders:cb77b9ab-f94d-4013-85b7-644b0b9ba9a9',
        //     event => 'orders'
        //   }
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $payload = $this->safe_dict($message, 'payload');
        $order = $this->safe_dict($payload, 'order');
        $parsed = $this->parse_ws_order($order);
        $this->orders.append ($parsed);
        $messageHash = $this->safe_string($message, 'topic');
        $client->resolve ($this->orders, $messageHash);
        return $message;
    }

    public function parse_ws_order($order, $market = null) {
        //      {
        //         $id => 'eed7ce96-f34b-483d-8d87-925eef6f0702',
        //         status => 'new',
        //         type => 'limit',
        //         symbol => 'CLEO-ALEO',
        //         inserted_at => '2024-10-04T02:29:35.693172Z',
        //         account_id => 'cb77b9ab-f94d-4013-85b7-644b0b9ba9a9',
        //         updated_at => '2024-10-04T02:29:36.254349Z',
        //         filled_quantity => '0',
        //         base_quantity => '0.1',
        //         idempotency_key => '99888999-93ef-9831-9829-820a082bfcf8',
        //         price => '1.1',
        //         remained_quantity => '0.1',
        //         side => 'buy',
        //         time_in_force => 'gtc',
        //         canceled_at => null,
        //         average_filled_price => null,
        //         canceled_quantity => '0',
        //         cumulative_fee => '0',
        //         fee_asset => null,
        //         filled_at => null,
        //         filled_value => '0',
        //         lock_version => 3,
        //         quote_quantity => null,
        //         sequence_id => 187,
        //         settled_quantity => '0'
        //       }
        $id = $this->safe_string($order, 'id');
        $clientOrderId = $this->safe_string($order, 'idempotency_key');
        $createdDateTime = $this->safe_string($order, 'inserted_at');
        $filledDateTime = $this->safe_string($order, 'filled_at');
        $updatedDateTime = $this->safe_string($order, 'updated_at');
        return $this->safe_order(array(
            'info' => $order,
            'symbol' => $this->safe_string($order, 'symbol'),
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $this->parse8601($createdDateTime),
            'datetime' => $createdDateTime,
            'lastTradeTimestamp' => $filledDateTime ? $this->parse8601($filledDateTime) : null,
            'type' => $this->safe_string($order, 'type'),
            'timeInForce' => $this->safe_string($order, 'time_in_force', 'gtc'),
            'postOnly' => true,
            'side' => $this->safe_string($order, 'side'),
            'price' => $this->safe_string($order, 'price'),
            'stopPrice' => null,
            'triggerPrice' => null,
            'amount' => $this->safe_string($order, 'base_quantity'),
            'cost' => null,
            'average' => $this->safe_string($order, 'average_filled_price'),
            'filled' => $this->safe_string($order, 'filled_quantity'),
            'remaining' => $this->safe_string($order, 'remained_quantity'),
            'status' => $this->safe_string_lower($order, 'status'),
            'fee' => array(
                'cost' => $this->safe_string($order, 'cumulative_fee'),
                'currency' => $this->safe_string($market, 'fee_asset'),
            ),
            'trades' => null,
            'lastUpdatedTimestamp' => $updatedDateTime ? $this->parse8601($updatedDateTime) : null,
        ));
    }

    public function handle_subscription_status($client, $message) {
        //
        //     {
        //         "type" => "subscriptions",
        //         "channels" => array(
        //             {
        //                 "name" => "level2",
        //                 "product_ids" => array( "ETH-BTC" )
        //             }
        //         )
        //     }
        //
        return $message;
    }

    public function handle_heartbeats($client, $message) {
        // although the subscription takes a product_ids parameter (i.e. symbol),
        // there is no (clear) way of mapping the $message back to the symbol.
        //
        //     {
        //         "channel" => "heartbeats",
        //         "client_id" => "",
        //         "timestamp" => "2023-06-23T20:31:26.122969572Z",
        //         "sequence_num" => 0,
        //         "events" => array(
        //           {
        //               "current_time" => "2023-06-23 20:31:56.121961769 +0000 UTC m=+91717.525857105",
        //               "heartbeat_counter" => "3049"
        //           }
        //         )
        //     }
        //
        return $message;
    }

    public function handle_message($client, $message) {
        $channel = $this->safe_string($this->safe_dict($message, 'payload'), 'channel');
        $methods = array(
            // 'subscriptions' => array($this, 'handle_subscription_status'),
            'trades' => array($this, 'handle_trade'),
            'orders' => array($this, 'handle_order'),
            // 'heartbeats' => array($this, 'handle_heartbeats'),
        );
        $type = $this->safe_string($message, 'type');
        if ($type === 'error') {
            $errorMessage = $this->safe_string($message, 'message');
            throw new ExchangeError($errorMessage);
        }
        $method = $this->safe_value($methods, $channel);
        if ($method) {
            $method($client, $message);
        }
    }
}
