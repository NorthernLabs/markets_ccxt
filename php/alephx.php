<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\abstract\alephx as Exchange;

class alephx extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'alephx',
            'name' => 'AlephX',
            'countries' => array( 'CA' ),
            'pro' => true,
            'certified' => false,
            // rate-limits => N/A
            'rateLimit' => 1000,
            'version' => 'v1',
            'userAgent' => $this->userAgents['chrome'],
            // 'headers' => array(
            //     'ZKX-VERSION' => '2018-05-30',
            // ),
            'has' => array(
                'CORS' => true,
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'closeAllPositions' => false,
                'closePosition' => true,
                'createConvertTrade' => true,
                'createDepositAddress' => true,
                'createLimitBuyOrder' => true,
                'createLimitSellOrder' => true,
                'createMarketBuyOrder' => true,
                'createMarketBuyOrderWithCost' => true,
                'createMarketOrderWithCost' => false,
                'createMarketSellOrder' => true,
                'createMarketSellOrderWithCost' => false,
                'createOrder' => true,
                'createPostOnlyOrder' => true,
                'createReduceOnlyOrder' => false,
                'createStopLimitOrder' => true,
                'createStopMarketOrder' => false,
                'createStopOrder' => true,
                'deposit' => true,
                'editOrder' => true,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchBidsAsks' => true,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchCanceledOrders' => true,
                'fetchClosedOrders' => true,
                'fetchConvertQuote' => true,
                'fetchConvertTrade' => true,
                'fetchConvertTradeHistory' => false,
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => true,
                'fetchDeposit' => true,
                'fetchDepositAddress' => 'emulated',
                'fetchDepositAddresses' => false,
                'fetchDepositAddressesByNetwork' => true,
                'fetchDeposits' => true,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchL2OrderBook' => false,
                'fetchLedger' => true,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => false,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyBuys' => true,
                'fetchMySells' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchPosition' => true,
                'fetchPositionMode' => false,
                'fetchPositions' => true,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => 'emulated',
                'fetchTradingFees' => true,
                'fetchWithdrawals' => true,
                'reduceMargin' => false,
                'setLeverage' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'withdraw' => true,
            ),
            'urls' => array(
                // 'logo' => 'https://user-images.githubusercontent.com/1294454/40811661-b6eceae2-653a-11e8-829e-10bfadb078cf.jpg',
                'api' => array(
                    'rest' => 'https://api.alephx.xyz',
                ),
                'www' => 'https://demo.alephx.xyz',
                // 'doc' => array(
                //     'https://developers.alephx.com/api/v1',
                // ),
                // 'fees' => array(
                //     'https://support.alephx.com/customer/portal/articles/2109597-buy-sell-bank-transfer-fees',
                // ),
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
            ),
            'api' => array(
                'v1' => array(
                    'private' => array(
                        'get' => array(
                            'orders' => 0,
                            'orders/{id}' => 0,
                            'trades' => 0,
                        ),
                        'post' => array(
                            'orders' => 0,
                        ),
                        'patch' => array(
                            'orders/{id}/cancel' => 0,
                        ),
                    ),
                ),
            ),
            'exceptions' => array(
                'exact' => array(),
                'broad' => array(
                    'Wallet not allowed' => '\\ccxt\\AuthenticationError',
                    'Invalid signature' => '\\ccxt\\AuthenticationError',
                    'Unauthorized' => '\\ccxt\\PermissionDenied',
                    'Order is not cancellable' => '\\ccxt\\BadRequest',
                    'Asset is not supported' => '\\ccxt\\BadRequest',
                    'Not Found' => '\\ccxt\\OrderNotFound',
                ),
            ),
        ));
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        /**
         * create an order
         * @see POST https://api.alephx.xyz/api/v1/orders
         * @param {string} $symbol unified $symbol of the market to create an order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much you want to trade in units of the base currency, quote currency for 'market' 'buy' orders
         * @param {float} [$price] the $price to fulfill the order, in units of the quote currency, ignored in market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->timeInForce] 'gtc'
         * @param {string} [$params->idempotencyKey] uuid for idempotency key
         * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
         */
        $request = array(
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'quantity' => (string) $amount,
            'price' => (string) $price,
            'time_in_force' => $this->safe_string_2($params, 'timeInForce', 'gtc'),
            'idempotency_key' => $this->safe_string_2($params, 'idempotencyKey', $this->uuid()),
        );
        $response = $this->v1PrivatePostOrders ($request);
        //
        // successful order
        //
        //
        // failed order
        //
        //
        $errorResponse = $this->safe_dict($response, 'error');
        if ($errorResponse !== null) {
            $errorReason = $this->safe_string($errorResponse, 'reason');
            $errorMessage = $this->safe_string($errorResponse, 'message');
            throw new ExchangeError($errorReason . '' . $errorMessage);
        }
        return $this->parse_order($response);
    }

    public function parse_order(array $order, ?array $market = null): array {
        //
        // createOrder
        //
        // {
        //    "order_id" => "52cfe5e2-0b29-4c19-a245-a6a773de5030",
        //    "status" => "pending_new"
        // }
        //
        //
        // fetchOrder, fetchOrders, cancelOrder
        //
        // {
        //     "id" => "0da4eb8d-c108-4e6c-8c45-0b42fabd3a72",
        //     "status" => "partially_filled",
        //     "type" => "limit",
        //     "symbol" => "CLEO-ALEO",
        //     "account_id" => "cb77b9ab-f94d-4013-85b7-644b0b9ba9a9",
        //     "settled_quantity" => "0",
        //     "base_quantity" => "0.1",
        //     "filled_quantity" => "0.04",
        //     "side" => "buy",
        //     "price" => "12.3",
        //     "remained_quantity" => "0.06",
        //     "idempotency_key" => "99888999-93ef-9831-9829-120a082bfcf2",
        //     "inserted_at" => "2024-09-16T23:47:45.161888Z",
        //     "fee_asset":null,
        //     "filled_at" => "2024-09-26T20:08:11.350542Z",
        //     "average_filled_price" => "12.3",
        //     "canceled_at":null,"cumulative_fee" => "0",
        //     "time_in_force" => "gtc",
        //     "internal_status" => "partially_filled"
        // }
        //
        $createdDateTime = $this->safe_string($order, 'inserted_at');
        $filledDateTime = $this->safe_string($order, 'filled_at');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $this->safe_string($order, 'order_id') || $this->safe_string($order, 'id'),
            'clientOrderId' => $this->safe_string($order, 'idempotency_key'),
            'timestamp' => $createdDateTime ? $this->parse8601($createdDateTime) : null,
            'datetime' => $createdDateTime,
            'lastTradeTimestamp' => $filledDateTime ? $this->parse8601($filledDateTime) : null,
            'symbol' => $this->safe_string($order, 'symbol'),
            'type' => $this->safe_string($order, 'type'),
            'timeInForce' => $this->safe_string($order, 'time_in_force', 'gtc'),
            'postOnly' => true,
            'side' => $this->safe_string_lower($order, 'side'),
            'price' => $this->safe_string($order, 'price'),
            'stopPrice' => null,
            'triggerPrice' => null,
            'amount' => $this->safe_string($order, 'base_quantity'),
            'filled' => $this->safe_string($order, 'filled_quantity'),
            'remaining' => $this->safe_string($order, 'remained_quantity'),
            'cost' => null,
            'average' => $this->safe_string($order, 'average_filled_price'),
            'status' => $this->safe_string($order, 'status'),
            'fee' => array(
                'cost' => $this->safe_string($order, 'cumulative_fee'),
                'currency' => $this->safe_string($order, 'fee_asset'),
            ),
            'trades' => null,
        ), $market);
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()) {
        /**
         * cancels an open order
         * @see PATCH https://api.alephx.xyz/api/v1/orders/{order_id}/cancel
         * @param {string} $id order $id
         * @param {string} $symbol not used by alephx cancelOrder()
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $request = array(
            'id' => $id, // order $id
        );
        $response = $this->v1PrivatePatchOrdersIdCancel ($this->extend($request, $params));
        $errorResponse = $this->safe_dict($response, 'error');
        if ($errorResponse !== null) {
            $errorReason = $this->safe_string($errorResponse, 'reason');
            $errorMessage = $this->safe_string($errorResponse, 'message');
            if ($errorReason === 'Not Found') {
                throw new OrderNotFound($this->id . ' cancelOrder() error ' . $errorReason);
            } elseif ($errorReason === 'Bad Request') {
                throw new BadRequest($this->id . ' cancelOrder() error ' . $errorReason . ' ' . $errorMessage);
            } else {
                throw new ExchangeError($errorReason . '' . $errorMessage);
            }
        }
        return $this->parse_order($response);
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()) {
        /**
         * fetches information on an order made by the user
         * @see GET https://api.alephx.xyz/api/v1/orders/{order_id}
         * @param {string} $id the order $id
         * @param {string} $symbol unified market $symbol that the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
         */
        $request = array(
            'id' => $id, // order $id
        );
        $response = $this->v1PrivateGetOrdersId ($this->extend($request, $params));
        $errorResponse = $this->safe_dict($response, 'error');
        if ($errorResponse !== null) {
            $errorReason = $this->safe_string($errorResponse, 'reason');
            if ($errorReason === 'Not Found') {
                throw new OrderNotFound($this->id . ' fetchOrder() error ' . $errorReason);
            }
        }
        return $this->parse_order($response);
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = 100, $params = array ()): array {
        /**
         * fetches information on multiple orders made by the user
         * @see GET https://api.alephx.xyz/api/v1/orders/
         * @param {string} $symbol unified $market $symbol that the orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch trades for
         * @param {boolean} [$params->paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structures~
         */
        $response = $this->v1PrivateGetOrders ();
        $market = null;
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch all $trades made by the user
         * @see GET https://api.alephx.xyz/api/v1/trades
         * @param {string} $symbol unified $market $symbol of the $trades
         * @param {int} [$since] timestamp in ms of the earliest order, default is null
         * @param {int} [$limit] the maximum number of trade structures to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch $trades for
         * @param {boolean} [$params->paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
         */
        $response = $this->v1PrivateGetTrades ();
        $trades = $this->safe_list($response, 'data');
        $market = null;
        //
        // { "data" => [
        //   array( "id" => "32672029-b46b-4139-9779-95444053f40a",
        //     "status" => "unsettled",
        //     "symbol" => "CLEO-ALEO",
        //     "base_quantity" => "0.01",
        //     "side" => "buy",
        //     "price" => "12.3",
        //     "buy_order_id" => "0da4eb8d-c108-4e6c-8c45-0b42fabd3a72",
        //     "sell_order_id" => "86c61562-ff14-43c9-9a03-4be804d184d0",
        //     "quote_quantity" => "0.123",
        //     "inserted_at" => "2024-09-26T15:18:06.603489Z",
        //     "aggressor_side" => "sell",
        //     "fee" => null,
        //     "fee_asset" => null,
        //     "updated_at" => "2024-09-26T15:18:06.603489Z"
        //  )]}
        //
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function parse_trade(array $trade, ?array $market = null): array {
        // returned $trade
        //
        // array(
        //   {
        //     id => '32672029-b46b-4139-9779-95444053f40a',
        //     order => '0da4eb8d-c108-4e6c-8c45-0b42fabd3a72',
        //     info => array(
        //     id => '32672029-b46b-4139-9779-95444053f40a',
        //     status => 'unsettled',
        //     symbol => 'CLEO-ALEO',
        //     base_quantity => '0.01',
        //     side => 'buy',
        //     price => '12.3',
        //     buy_order_id => '0da4eb8d-c108-4e6c-8c45-0b42fabd3a72',
        //     sell_order_id => '86c61562-ff14-43c9-9a03-4be804d184d0',
        //     quote_quantity => '0.123',
        //     inserted_at => '2024-09-26T15:18:06.603489Z',
        //     aggressor_side => 'sell',
        //     fee => null,
        //     fee_asset => null,
        //     updated_at => '2024-09-26T15:18:06.603489Z'
        //     ),
        //     timestamp => 1727363886603,
        //     datetime => '2024-09-26T15:18:06.603489Z',
        //     symbol => 'CLEO-ALEO',
        //     type => null,
        //     side => 'buy',
        //     takerOrMaker => null,
        //     price => 12.3,
        //     amount => 0.01,
        //     cost => 0.123,
        //     fee => array( cost => null, currency => null ),
        //     fees => array()
        //   }
        // )
        $createdDateTime = $this->safe_string($trade, 'inserted_at');
        $traderSide = $this->safe_string($trade, 'side');
        $traderOrderId = $traderSide === 'buy' ? $this->safe_string($trade, 'buy_order_id') : $this->safe_string($trade, 'sell_order_id');
        return $this->safe_trade(array(
            'id' => $this->safe_string($trade, 'id'),
            'order' => $traderOrderId,
            'info' => $trade,
            'timestamp' => $this->parse8601($createdDateTime),
            'datetime' => $createdDateTime,
            'symbol' => $this->safe_string($trade, 'symbol'),
            'type' => null,
            'side' => $traderSide,
            'takerOrMaker' => null,
            'price' => $this->safe_string($trade, 'price'),
            'amount' => $this->safe_string($trade, 'base_quantity'),
            'cost' => $this->safe_string($trade, 'quote_quantity'),
            'fee' => array(
                'cost' => $this->safe_string($trade, 'fee'),
                'currency' => $this->safe_string($trade, 'fee_asset'),
            ),
        ), $market);
    }

    public function sign($path, $api = [], $method = 'GET', $params = array (), $headers = null, $body = null) {
        $version = $api[0];
        $signed = $api[1] === 'private';
        $fullPath = '/api/' . $version . '/' . $this->implode_params($path, $params);
        $query = $this->omit($params, $this->extract_params($path));
        $savedPath = $fullPath;
        if ($method === 'GET') {
            if ($query) {
                $fullPath .= '?' . $this->urlencode_with_array_repeat($query);
            }
        }
        $url = $this->urls['api']['rest'] . $fullPath;
        if ($signed) {
            $authorization = $this->safe_string($this->headers, 'Authorization');
            $authorizationString = null;
            if ($authorization !== null) {
                $authorizationString = $authorization;
            } elseif ($this->token && !$this->check_required_credentials(false)) {
                $authorizationString = 'Bearer ' . $this->token;
            } else {
                $this->check_required_credentials();
                if ($method !== 'GET') {
                    if ($query) {
                        $body = $this->json($query);
                    }
                }
                // doesn't need payload in the $signature-> inside $url is enough
                $timestampString = (string) $this->seconds();
                $auth = $timestampString . $method . $savedPath;
                $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256');
                $headers = array(
                    'ZKX_ACCESS_KEY' => $this->apiKey,
                    'ZKX_ACCESS_SIGN' => $signature,
                    'ZKX_ACCESS_TIMESTAMP' => $timestampString,
                    'Content-Type' => 'application/json',
                );
            }
            if ($authorizationString !== null) {
                $headers = array(
                    'Authorization' => $authorizationString,
                    'Content-Type' => 'application/json',
                );
                if ($method !== 'GET') {
                    if ($query) {
                        $body = $this->json($query);
                    }
                }
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors(int $code, string $reason, string $url, string $method, array $headers, string $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return null; // fallback to default error handler
        }
        $feedback = $this->id . ' ' . $body;
        //
        //
        //    {
        //      "error" => {
        //        {
        //          "reason" => "Bad Request",
        //          "message" => "Order is not cancellable"
        //        }
        //      }
        //    }
        //
        $errorResponse = $this->safe_dict($response, 'error');
        $errorCode = $this->safe_string($errorResponse, 'reason');
        if ($errorCode !== null) {
            $errorMessage = $this->safe_string($errorResponse, 'message');
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $errorMessage, $feedback);
            throw new ExchangeError($feedback);
        }
        // $errors = $this->safe_list($response, 'errors');
        // if ($errors !== null) {
        //     if (gettype($errors) === 'array' && array_keys($errors) === array_keys(array_keys($errors))) {
        //         $numErrors = count($errors);
        //         if ($numErrors > 0) {
        //             $errorCode = $this->safe_string($errors[0], 'id');
        //             $errorMessage = $this->safe_string($errors[0], 'message');
        //             if ($errorCode !== null) {
        //                 $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
        //                 $this->throw_broadly_matched_exception($this->exceptions['broad'], $errorMessage, $feedback);
        //                 throw new ExchangeError($feedback);
        //             }
        //         }
        //     }
        // }
        return null;
    }
}
