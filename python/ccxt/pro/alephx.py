# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxt.async_support
from ccxt.async_support.base.ws.cache import ArrayCacheBySymbolById
import hashlib
from ccxt.base.types import Int, Order, Str, Trade
from typing import List
from ccxt.base.errors import ExchangeError


class alephx(ccxt.async_support.alephx):

    def describe(self):
        return self.deep_extend(super(alephx, self).describe(), {
            'has': {
                'ws': True,
                'cancelAllOrdersWs': False,
                'cancelOrdersWs': False,
                'cancelOrderWs': False,
                'createOrderWs': False,
                'editOrderWs': False,
                'fetchBalanceWs': False,
                'fetchOpenOrdersWs': False,
                'fetchOrderWs': False,
                'fetchTradesWs': False,
                'watchBalance': False,
                'watchMyTrades': True,
                'watchOHLCV': False,
                'watchOrderBook': False,
                'watchOrderBookForSymbols': False,
                'watchOrders': True,
                'watchTicker': False,
                'watchTickers': False,
                'watchTrades': False,
                'watchTradesForSymbols': False,
            },
            'urls': {
                'api': {
                    'ws': 'wss://api.alephx.xyz/websocket',
                },
            },
            'options': {
                'tradesLimit': 1000,
                'ordersLimit': 1000,
                'myTradesLimit': 1000,
                'sides': {
                    'bid': 'bids',
                    'offer': 'asks',
                },
            },
        })

    async def subscribe(self, name: str, isPrivate: bool, symbol=None, params={}):
        """
         * @ignore
        subscribes to a websocket channel
        :see: https://api.alephx.xyz/websocket
        :param str name: the name of the channel
        :param string|str[] [symbol]: unified market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: subscription to a websocket channel
        """
        url = self.urls['api']['ws']
        messageHash = name
        if isPrivate:
            auth = self.create_ws_auth()
            url = url + '?api_key=' + auth['api_key'] + '&timestamp=' + auth['timestamp'] + '&signature=' + auth['signature']
            messageHash = messageHash + ':' + auth['api_key']
        subscribe = {
            'event': 'phx_join',
            'topic': messageHash,
            'payload': {},
            'ref': messageHash,
            'join_ref': messageHash,
        }
        return await self.watch(url, messageHash, subscribe, messageHash)

    def create_ws_auth(self):
        subscribe: dict = {}
        timestamp = self.number_to_string(self.seconds())
        self.check_required_credentials()
        auth = timestamp
        subscribe['api_key'] = self.apiKey
        subscribe['timestamp'] = timestamp
        subscribe['signature'] = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256)
        return subscribe

    async def watch_my_trades(self, symbol: str = None, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        watches information on multiple trades made by the user
        :see: trades channel
        :param str symbol: unified symbol of the market to fetch trades for
        :param int [since]: timestamp in ms of the earliest trade to fetch
        :param int [limit]: the maximum amount of trades to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        name = 'trades'
        trades = await self.subscribe(name, True, symbol, params)
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_since_limit(trades, since, limit, 'timestamp', True)

    async def watch_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        watches information on multiple orders made by the user
        :see: orders channel
        :param str [symbol]: unified market symbol of the market orders were made in
        :param int [since]: the earliest time in ms to fetch orders for
        :param int [limit]: the maximum number of order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        name = 'orders'
        orders = await self.subscribe(name, True, symbol, params)
        if self.newUpdates:
            limit = orders.getLimit(symbol, limit)
        return self.filter_by_since_limit(orders, since, limit, 'timestamp', True)

    def handle_trade(self, client, message):
        # {
        #     ref: null,
        #     payload: {
        #       timestamp: '2024-10-04T03:11:30.111216Z',
        #       channel: 'trades',
        #       trade: {
        #         symbol: 'CLEO-ALEO',
        #         price: '1.1',
        #         base_quantity: '0.1',
        #         quote_quantity: '0.11',
        #         buy_order_id: 'ad2066e6-a47c-449d-99be-79ac82e7d163',
        #         sell_order_id: '1676786b-145f-4dcf-adde-74e5cce9ebc3',
        #         status: 'unsettled',
        #         aggressor_side: 'sell',
        #         id: 'e0b8354a-d71a-4577-bee5-ce52d8fabcf5',
        #         fee: null,
        #         fee_asset: null
        #       }
        #     },
        #     topic: 'trades:cb77b9ab-f94d-4013-85b7-644b0b9ba9a9',
        #     event: 'trades'
        #   }
        if self.myTrades is None:
            limit = self.safe_integer(self.options, 'tradesLimit', 1000)
            self.myTrades = ArrayCacheBySymbolById(limit)
        payload = self.safe_dict(message, 'payload')
        trade = self.safe_dict(payload, 'trade')
        parsed = self.parse_ws_trade(trade)
        self.myTrades.append(parsed)
        messageHash = self.safe_string(message, 'topic')
        client.resolve(self.myTrades, messageHash)
        return message

    def parse_ws_trade(self, trade, market=None):
        #      {
        #         symbol: 'CLEO-ALEO',
        #         price: '1.1',
        #         base_quantity: '0.1',
        #         quote_quantity: '0.11',
        #         buy_order_id: 'ad2066e6-a47c-449d-99be-79ac82e7d163',
        #         sell_order_id: '1676786b-145f-4dcf-adde-74e5cce9ebc3',
        #         status: 'unsettled',
        #         aggressor_side: 'sell',
        #         id: 'e0b8354a-d71a-4577-bee5-ce52d8fabcf5',
        #         fee: null,
        #         fee_asset: null
        #       }
        createdDateTime = self.safe_string(trade, 'inserted_at')
        traderSide = self.safe_string(trade, 'side')
        traderOrderId = traderSide == self.safe_string(trade, 'buy_order_id') if 'buy' else self.safe_string(trade, 'sell_order_id')
        return self.safe_trade({
            'id': self.safe_string(trade, 'id'),
            'order': traderOrderId,
            'info': trade,
            'timestamp': self.parse8601(createdDateTime),
            'datetime': createdDateTime,
            'symbol': self.safe_string(trade, 'symbol'),
            'type': 'gtc',
            'side': traderSide,
            'takerOrMaker': None,
            'price': self.safe_string(trade, 'price'),
            'amount': self.safe_string(trade, 'base_quantity'),
            'cost': self.safe_string(trade, 'quote_quantity'),
            'fee': {
                'cost': self.safe_string(trade, 'fee'),
                'currency': self.safe_string(trade, 'fee_asset'),
            },
        }, market)

    def handle_order(self, client, message):
        # {
        #     ref: null,
        #     payload: {
        #       timestamp: '2024-10-04T02:29:36.263148Z',
        #       channel: 'orders',
        #       order: {
        #         id: 'eed7ce96-f34b-483d-8d87-925eef6f0702',
        #         status: 'new',
        #         type: 'limit',
        #         symbol: 'CLEO-ALEO',
        #         inserted_at: '2024-10-04T02:29:35.693172Z',
        #         account_id: 'cb77b9ab-f94d-4013-85b7-644b0b9ba9a9',
        #         updated_at: '2024-10-04T02:29:36.254349Z',
        #         filled_quantity: '0',
        #         base_quantity: '0.1',
        #         idempotency_key: '99888999-93ef-9831-9829-820a082bfcf8',
        #         price: '1.1',
        #         remained_quantity: '0.1',
        #         side: 'buy',
        #         time_in_force: 'gtc',
        #         canceled_at: null,
        #         average_filled_price: null,
        #         canceled_quantity: '0',
        #         cumulative_fee: '0',
        #         fee_asset: null,
        #         filled_at: null,
        #         filled_value: '0',
        #         lock_version: 3,
        #         quote_quantity: null,
        #         sequence_id: 187,
        #         settled_quantity: '0'
        #       }
        #     },
        #     topic: 'orders:cb77b9ab-f94d-4013-85b7-644b0b9ba9a9',
        #     event: 'orders'
        #   }
        if self.orders is None:
            limit = self.safe_integer(self.options, 'ordersLimit', 1000)
            self.orders = ArrayCacheBySymbolById(limit)
        payload = self.safe_dict(message, 'payload')
        order = self.safe_dict(payload, 'order')
        parsed = self.parse_ws_order(order)
        self.orders.append(parsed)
        messageHash = self.safe_string(message, 'topic')
        client.resolve(self.orders, messageHash)
        return message

    def parse_ws_order(self, order, market=None):
        #      {
        #         id: 'eed7ce96-f34b-483d-8d87-925eef6f0702',
        #         status: 'new',
        #         type: 'limit',
        #         symbol: 'CLEO-ALEO',
        #         inserted_at: '2024-10-04T02:29:35.693172Z',
        #         account_id: 'cb77b9ab-f94d-4013-85b7-644b0b9ba9a9',
        #         updated_at: '2024-10-04T02:29:36.254349Z',
        #         filled_quantity: '0',
        #         base_quantity: '0.1',
        #         idempotency_key: '99888999-93ef-9831-9829-820a082bfcf8',
        #         price: '1.1',
        #         remained_quantity: '0.1',
        #         side: 'buy',
        #         time_in_force: 'gtc',
        #         canceled_at: null,
        #         average_filled_price: null,
        #         canceled_quantity: '0',
        #         cumulative_fee: '0',
        #         fee_asset: null,
        #         filled_at: null,
        #         filled_value: '0',
        #         lock_version: 3,
        #         quote_quantity: null,
        #         sequence_id: 187,
        #         settled_quantity: '0'
        #       }
        id = self.safe_string(order, 'id')
        clientOrderId = self.safe_string(order, 'idempotency_key')
        createdDateTime = self.safe_string(order, 'inserted_at')
        filledDateTime = self.safe_string(order, 'filled_at')
        updatedDateTime = self.safe_string(order, 'updated_at')
        return self.safe_order({
            'info': order,
            'symbol': self.safe_string(order, 'symbol'),
            'id': id,
            'clientOrderId': clientOrderId,
            'timestamp': self.parse8601(createdDateTime),
            'datetime': createdDateTime,
            'lastTradeTimestamp': self.parse8601(filledDateTime) if filledDateTime else None,
            'type': self.safe_string(order, 'type'),
            'timeInForce': self.safe_string(order, 'time_in_force', 'gtc'),
            'postOnly': True,
            'side': self.safe_string(order, 'side'),
            'price': self.safe_string(order, 'price'),
            'stopPrice': None,
            'triggerPrice': None,
            'amount': self.safe_string(order, 'base_quantity'),
            'cost': None,
            'average': self.safe_string(order, 'average_filled_price'),
            'filled': self.safe_string(order, 'filled_quantity'),
            'remaining': self.safe_string(order, 'remained_quantity'),
            'status': self.safe_string_lower(order, 'status'),
            'fee': {
                'amount': self.safe_string(order, 'cumulative_fee'),
                'currency': self.safe_string(market, 'fee_asset'),
            },
            'trades': None,
            'lastUpdatedTimestamp': self.parse8601(updatedDateTime) if updatedDateTime else None,
        })

    def handle_subscription_status(self, client, message):
        #
        #     {
        #         "type": "subscriptions",
        #         "channels": [
        #             {
        #                 "name": "level2",
        #                 "product_ids": ["ETH-BTC"]
        #             }
        #         ]
        #     }
        #
        return message

    def handle_heartbeats(self, client, message):
        # although the subscription takes a product_ids parameter(i.e. symbol),
        # there is no(clear) way of mapping the message back to the symbol.
        #
        #     {
        #         "channel": "heartbeats",
        #         "client_id": "",
        #         "timestamp": "2023-06-23T20:31:26.122969572Z",
        #         "sequence_num": 0,
        #         "events": [
        #           {
        #               "current_time": "2023-06-23 20:31:56.121961769 +0000 UTC m=+91717.525857105",
        #               "heartbeat_counter": "3049"
        #           }
        #         ]
        #     }
        #
        return message

    def handle_message(self, client, message):
        channel = self.safe_string(self.safe_dict(message, 'payload'), 'channel')
        methods: dict = {
            # 'subscriptions': self.handle_subscription_status,
            'trades': self.handle_trade,
            'orders': self.handle_order,
            # 'heartbeats': self.handle_heartbeats,
        }
        type = self.safe_string(message, 'type')
        if type == 'error':
            errorMessage = self.safe_string(message, 'message')
            raise ExchangeError(errorMessage)
        method = self.safe_value(methods, channel)
        if method:
            method(client, message)
