# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.abstract.alephx import ImplicitAPI
import hashlib
import json
from ccxt.base.types import Balances, Int, Market, Num, Order, OrderSide, OrderType, Str, Trade
from typing import List
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import BadRequest
from ccxt.base.errors import OrderNotFound


class alephx(Exchange, ImplicitAPI):

    def describe(self):
        return self.deep_extend(super(alephx, self).describe(), {
            'id': 'alephx',
            'name': 'AlephX',
            'countries': ['CA'],
            'pro': True,
            'certified': False,
            # rate-limits: N/A
            'rateLimit': 1000,
            'version': 'v1',
            'userAgent': self.userAgents['chrome'],
            # 'headers': {
            #     'ZKX-VERSION': '2018-05-30',
            # },
            'has': {
                'CORS': True,
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'addMargin': False,
                'cancelOrder': True,
                'cancelOrders': False,
                'createDepositAddress': False,
                'createLimitBuyOrder': False,
                'createLimitSellOrder': False,
                'createMarketBuyOrder': False,
                'createMarketBuyOrderWithCost': False,
                'createMarketOrderWithCost': False,
                'createMarketSellOrder': False,
                'createMarketSellOrderWithCost': False,
                'createOrder': True,
                'createPostOnlyOrder': False,
                'createReduceOnlyOrder': False,
                'createStopLimitOrder': False,
                'createStopMarketOrder': False,
                'createStopOrder': True,
                'deposit': False,
                'editOrder': False,
                'fetchAccounts': False,
                'fetchBalance': True,
                'fetchBidsAsks': False,
                'fetchCanceledOrders': False,
                'fetchCurrencies': False,
                'fetchDeposit': False,
                'fetchDepositAddress': False,
                'fetchDepositAddresses': False,
                'fetchDepositAddressesByNetwork': False,
                'fetchDeposits': False,
                'fetchFundingHistory': False,
                'fetchFundingRate': False,
                'fetchFundingRateHistory': False,
                'fetchFundingRates': False,
                'fetchIndexOHLCV': False,
                'fetchIsolatedBorrowRate': False,
                'fetchIsolatedBorrowRates': False,
                'fetchL2OrderBook': False,
                'fetchLedger': False,
                'fetchLeverage': False,
                'fetchLeverageTiers': False,
                'fetchMarginMode': False,
                'fetchMarkets': False,
                'fetchMarkOHLCV': False,
                'fetchMyBuys': False,
                'fetchMySells': False,
                'fetchMyTrades': True,
                'fetchOHLCV': False,
                'fetchOpenInterestHistory': False,
                'fetchOpenOrders': False,
                'fetchOrder': True,
                'fetchOrderBook': False,
                'fetchOrders': True,
                'fetchOrderTrades': True,
                'fetchPosition': False,
                'fetchPositionMode': False,
                'fetchPositions': False,
                'fetchPositionsRisk': False,
                'fetchPremiumIndexOHLCV': False,
                'fetchStatus': True,
                'fetchTicker': False,
                'fetchTickers': False,
                'fetchTime': False,
                'fetchTrades': False,
                'fetchTradingFee': 'emulated',
                'fetchTradingFees': False,
                'fetchWithdrawals': False,
                'reduceMargin': False,
                'setLeverage': False,
                'setMarginMode': False,
                'setPositionMode': False,
                'withdraw': False,
            },
            'urls': {
                # 'logo': 'https://user-images.githubusercontent.com/1294454/40811661-b6eceae2-653a-11e8-829e-10bfadb078cf.jpg',
                'api': {
                    'rest': 'https://api.alephx.xyz',
                },
                'www': 'https://demo.alephx.xyz',
                # 'doc': [
                #     'https://developers.alephx.com/api/v1',
                # ],
                # 'fees': [
                #     'https://support.alephx.com/customer/portal/articles/2109597-buy-sell-bank-transfer-fees',
                # ],
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
            },
            'api': {
                'v1': {
                    'public': {
                        'get': {
                            'system/status': 0,
                        },
                    },
                    'private': {
                        'get': {
                            'assets/balances': 0,
                            'orders': 0,
                            'orders/{id}': 0,
                            'trades': 0,
                        },
                        'post': {
                            'orders': 0,
                        },
                        'patch': {
                            'orders/{id}/cancel': 0,
                        },
                    },
                },
            },
            'exceptions': {
                'exact': {},
                'broad': {
                    'Wallet not allowed': AuthenticationError,
                    'Invalid signature': AuthenticationError,
                    'Unauthorized': PermissionDenied,
                    'Order is not cancellable': BadRequest,
                    'Asset is not supported': BadRequest,
                    'Not Found': OrderNotFound,
                },
            },
        })

    async def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}):
        """
        create an order
        :see: POST https://api.alephx.xyz/api/v1/orders
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency, quote currency for 'market' 'buy' orders
        :param float [price]: the price to fulfill the order, in units of the quote currency, ignored in market orders
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.timeInForce]: 'gtc'
        :param str [params.idempotencyKey]: uuid for idempotency key
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        request: dict = {
            'symbol': symbol,
            'type': type,
            'side': side,
            'quantity': str(amount),
            'price': str(price),
            'time_in_force': self.safe_string_2(params, 'timeInForce', 'gtc'),
            'idempotency_key': self.safe_string_2(params, 'idempotencyKey', self.uuid()),
        }
        response = await self.v1PrivatePostOrders(request)
        #
        # successful order
        #
        #
        # failed order
        #
        #
        errorResponse = self.safe_dict(response, 'error')
        if errorResponse is not None:
            errorReason = self.safe_string(errorResponse, 'reason')
            errorMessage = self.safe_string(errorResponse, 'message')
            raise ExchangeError(errorReason + '' + errorMessage)
        return self.parse_order(response)

    def parse_order(self, order: dict, market: Market = None) -> Order:
        #
        # createOrder
        #
        # {
        #    "order_id": "52cfe5e2-0b29-4c19-a245-a6a773de5030",
        #    "status": "pending_new"
        # }
        #
        #
        # fetchOrder, fetchOrders, cancelOrder
        #
        # {
        #     "id": "0da4eb8d-c108-4e6c-8c45-0b42fabd3a72",
        #     "status": "partially_filled",
        #     "type": "limit",
        #     "symbol": "CLEO-ALEO",
        #     "account_id": "cb77b9ab-f94d-4013-85b7-644b0b9ba9a9",
        #     "settled_quantity": "0",
        #     "base_quantity": "0.1",
        #     "filled_quantity": "0.04",
        #     "side": "buy",
        #     "price": "12.3",
        #     "remained_quantity": "0.06",
        #     "idempotency_key": "99888999-93ef-9831-9829-120a082bfcf2",
        #     "inserted_at": "2024-09-16T23:47:45.161888Z",
        #     "fee_asset":null,
        #     "filled_at": "2024-09-26T20:08:11.350542Z",
        #     "average_filled_price": "12.3",
        #     "canceled_at":null,"cumulative_fee": "0",
        #     "time_in_force": "gtc",
        #     "internal_status": "partially_filled"
        # }
        #
        createdDateTime = self.safe_string(order, 'inserted_at')
        filledDateTime = self.safe_string(order, 'filled_at')
        return self.safe_order({
            'info': order,
            'id': self.safe_string(order, 'order_id') or self.safe_string(order, 'id'),
            'clientOrderId': self.safe_string(order, 'idempotency_key'),
            'timestamp': self.parse8601(createdDateTime) if createdDateTime else None,
            'datetime': createdDateTime,
            'lastTradeTimestamp': self.parse8601(filledDateTime) if filledDateTime else None,
            'symbol': self.safe_string(order, 'symbol'),
            'type': self.safe_string(order, 'type'),
            'timeInForce': self.safe_string(order, 'time_in_force', 'gtc'),
            'postOnly': True,
            'side': self.safe_string_lower(order, 'side'),
            'price': self.safe_string(order, 'price'),
            'stopPrice': None,
            'triggerPrice': None,
            'amount': self.safe_string(order, 'base_quantity'),
            'filled': self.safe_string(order, 'filled_quantity'),
            'remaining': self.safe_string(order, 'remained_quantity'),
            'cost': None,
            'average': self.safe_string(order, 'average_filled_price'),
            'status': self.safe_string(order, 'status'),
            'fee': {
                'cost': self.safe_string(order, 'cumulative_fee'),
                'currency': self.safe_string(order, 'fee_asset'),
            },
            'trades': None,
        }, market)

    async def cancel_order(self, id: str, symbol: Str = None, params={}):
        """
        cancels an open order
        :see: PATCH https://api.alephx.xyz/api/v1/orders/{order_id}/cancel
        :param str id: order id
        :param str symbol: not used by alephx cancelOrder()
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        request: dict = {
            'id': id,  # order id
        }
        response = await self.v1PrivatePatchOrdersIdCancel(self.extend(request, params))
        errorResponse = self.safe_dict(response, 'error')
        if errorResponse is not None:
            errorReason = self.safe_string(errorResponse, 'reason')
            errorMessage = self.safe_string(errorResponse, 'message')
            if errorReason == 'Not Found':
                raise OrderNotFound(self.id + ' cancelOrder() error ' + errorReason)
            elif errorReason == 'Bad Request':
                raise BadRequest(self.id + ' cancelOrder() error ' + errorReason + ' ' + errorMessage)
            else:
                raise ExchangeError(errorReason + '' + errorMessage)
        return self.parse_order(response)

    async def fetch_order(self, id: str, symbol: Str = None, params={}):
        """
        fetches information on an order made by the user
        :see: GET https://api.alephx.xyz/api/v1/orders/{order_id}
        :param str id: the order id
        :param str symbol: unified market symbol that the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        request: dict = {
            'id': id,  # order id
        }
        response = await self.v1PrivateGetOrdersId(self.extend(request, params))
        errorResponse = self.safe_dict(response, 'error')
        if errorResponse is not None:
            errorReason = self.safe_string(errorResponse, 'reason')
            if errorReason == 'Not Found':
                raise OrderNotFound(self.id + ' fetchOrder() error ' + errorReason)
        return self.parse_order(response)

    async def fetch_orders(self, symbol: Str = None, since: Int = None, limit: Int = 100, params={}) -> List[Order]:
        """
        fetches information on multiple orders made by the user
        :see: GET https://api.alephx.xyz/api/v1/orders/
        :param str symbol: unified market symbol that the orders were made in
        :param int [since]: the earliest time in ms to fetch orders
        :param int [limit]: the maximum number of order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.until]: the latest time in ms to fetch trades for
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :returns Order[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        response = await self.v1PrivateGetOrders()
        market = None
        return self.parse_orders(response, market, since, limit)

    async def fetch_my_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        """
        fetch all trades made by the user
        :see: GET https://api.alephx.xyz/api/v1/trades
        :param str symbol: unified market symbol of the trades
        :param int [since]: timestamp in ms of the earliest order, default is None
        :param int [limit]: the maximum number of trade structures to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.until]: the latest time in ms to fetch trades for
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :returns Trade[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        response = await self.v1PrivateGetTrades()
        trades = self.safe_list(response, 'data')
        market = None
        #
        # {"data": [
        #   {"id": "32672029-b46b-4139-9779-95444053f40a",
        #     "status": "unsettled",
        #     "symbol": "CLEO-ALEO",
        #     "base_quantity": "0.01",
        #     "side": "buy",
        #     "price": "12.3",
        #     "buy_order_id": "0da4eb8d-c108-4e6c-8c45-0b42fabd3a72",
        #     "sell_order_id": "86c61562-ff14-43c9-9a03-4be804d184d0",
        #     "quote_quantity": "0.123",
        #     "inserted_at": "2024-09-26T15:18:06.603489Z",
        #     "aggressor_side": "sell",
        #     "fee": null,
        #     "fee_asset": null,
        #     "updated_at": "2024-09-26T15:18:06.603489Z"
        #  }]}
        #
        return self.parse_trades(trades, market, since, limit)

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        # returned trade
        #
        # [
        #   {
        #     id: '32672029-b46b-4139-9779-95444053f40a',
        #     order: '0da4eb8d-c108-4e6c-8c45-0b42fabd3a72',
        #     info: {
        #     id: '32672029-b46b-4139-9779-95444053f40a',
        #     status: 'unsettled',
        #     symbol: 'CLEO-ALEO',
        #     base_quantity: '0.01',
        #     side: 'buy',
        #     price: '12.3',
        #     buy_order_id: '0da4eb8d-c108-4e6c-8c45-0b42fabd3a72',
        #     sell_order_id: '86c61562-ff14-43c9-9a03-4be804d184d0',
        #     quote_quantity: '0.123',
        #     inserted_at: '2024-09-26T15:18:06.603489Z',
        #     aggressor_side: 'sell',
        #     fee: null,
        #     fee_asset: null,
        #     updated_at: '2024-09-26T15:18:06.603489Z'
        #     },
        #     timestamp: 1727363886603,
        #     datetime: '2024-09-26T15:18:06.603489Z',
        #     symbol: 'CLEO-ALEO',
        #     type: None,
        #     side: 'buy',
        #     takerOrMaker: None,
        #     price: 12.3,
        #     amount: 0.01,
        #     cost: 0.123,
        #     fee: {cost: None, currency: None},
        #     fees: []
        #   }
        # ]
        createdDateTime = self.safe_string(trade, 'inserted_at')
        traderSide = self.safe_string(trade, 'side')
        traderOrderId = traderSide == self.safe_string(trade, 'buy_order_id') if 'buy' else self.safe_string(trade, 'sell_order_id')
        return self.safe_trade({
            'id': self.safe_string(trade, 'id'),
            'order': traderOrderId,
            'info': trade,
            'timestamp': self.parse8601(createdDateTime),
            'datetime': createdDateTime,
            'symbol': self.safe_string(trade, 'symbol'),
            'type': 'gtc',
            'side': traderSide,
            'takerOrMaker': None,
            'price': self.safe_string(trade, 'price'),
            'amount': self.safe_string(trade, 'base_quantity'),
            'cost': self.safe_string(trade, 'quote_quantity'),
            'fee': {
                'cost': self.safe_string(trade, 'fee'),
                'currency': self.safe_string(trade, 'fee_asset'),
            },
        }, market)

    async def fetch_order_trades(self, id: str, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        """
        fetch all the trades made from a single order
        :see: https://api.alephx.xyz/api/v1/trades?filters=[{"field":"order_id","op":"==","value":"order_id"}]
        :param str id: order id
        :param str symbol: unified market symbol
        :param int [since]: the earliest time in ms to fetch trades for
        :param int [limit]: the maximum number of trades to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        filters = []
        filter: dict = {
            'field': 'order_id',
            'op': '==',
            'value': id,
        }
        filters.append(filter)
        request: dict = {
            'filters': json.dumps(filters),
        }
        response = await self.v1PrivateGetTrades(request)
        trades = self.safe_list(response, 'data')
        market = None
        #
        # {"data": [
        #   {"id": "32672029-b46b-4139-9779-95444053f40a",
        #     "status": "unsettled",
        #     "symbol": "CLEO-ALEO",
        #     "base_quantity": "0.01",
        #     "side": "buy",
        #     "price": "12.3",
        #     "buy_order_id": "0da4eb8d-c108-4e6c-8c45-0b42fabd3a72",
        #     "sell_order_id": "86c61562-ff14-43c9-9a03-4be804d184d0",
        #     "quote_quantity": "0.123",
        #     "inserted_at": "2024-09-26T15:18:06.603489Z",
        #     "aggressor_side": "sell",
        #     "fee": null,
        #     "fee_asset": null,
        #     "updated_at": "2024-09-26T15:18:06.603489Z"
        #  }]}
        #
        return self.parse_trades(trades, market, since, limit)

    async def fetch_status(self, params={}):
        """
        the latest known information on the availability of the exchange API
        :see: https://api.alephx.xyz/api/v1/system/status
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `status structure <https://docs.ccxt.com/#/?id=exchange-status-structure>`
        """
        response = await self.v1PublicGetSystemStatus(params)
        #
        # OK
        #
        return {
            'status': 'ok' if (response == 'OK') else 'maintenance',
            'updated': None,
            'eta': None,
            'url': None,
            'info': response,
        }

    async def fetch_balance(self, params={}) -> Balances:
        """
        query for balance and get the amount of funds available for trading or funds locked in orders
        :see: https://api.alephx.xyz/api/v1/assets/balances
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/#/?id=balance-structure>`
        """
        # await self.load_markets()
        response = await self.v1PrivateGetAssetsBalances(params)
        # [
        #     {
        #         "total": "19.996900",
        #         "available": "14.756900",
        #         "asset": "CLEO",
        #         "locked": "5.240000"
        #     },
        #     {
        #         "total": "10.054720",
        #         "available": "-52.145280",
        #         "asset": "ALEO",
        #         "locked": "62.200000"
        #     }
        # ]
        return self.parse_balance(response)

    def parse_balance(self, response) -> Balances:
        balances = self.to_array(response)
        result: dict = {
            'info': response,
            'timestamp': None,
            'datetime': None,
        }
        for i in range(0, len(balances)):
            balance = balances[i]
            code = self.safe_string(balance, 'asset')
            account = self.account()
            account['free'] = self.safe_string(balance, 'available')
            account['used'] = self.safe_string(balance, 'locked')
            account['total'] = self.safe_string(balance, 'total')
            result[code] = account
        return self.safe_balance(result)

    def sign(self, path, api=[], method='GET', params={}, headers=None, body=None):
        version = api[0]
        signed = api[1] == 'private'
        fullPath = '/api/' + version + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        savedPath = fullPath
        if method == 'GET':
            if query:
                fullPath += '?' + self.urlencode_with_array_repeat(query)
        url = self.urls['api']['rest'] + fullPath
        if signed:
            authorization = self.safe_string(self.headers, 'Authorization')
            authorizationString = None
            if authorization is not None:
                authorizationString = authorization
            elif self.token and not self.check_required_credentials(False):
                authorizationString = 'Bearer ' + self.token
            else:
                self.check_required_credentials()
                if method != 'GET':
                    if query:
                        body = self.json(query)
                # doesn't need payload in the signature. inside url is enough
                timestampString = str(self.seconds())
                auth = timestampString + method + savedPath
                signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256)
                headers = {
                    'ZKX_ACCESS_KEY': self.apiKey,
                    'ZKX_ACCESS_SIGN': signature,
                    'ZKX_ACCESS_TIMESTAMP': timestampString,
                    'Content-Type': 'application/json',
                }
            if authorizationString is not None:
                headers = {
                    'Authorization': authorizationString,
                    'Content-Type': 'application/json',
                }
                if method != 'GET':
                    if query:
                        body = self.json(query)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code: int, reason: str, url: str, method: str, headers: dict, body: str, response, requestHeaders, requestBody):
        if response is None:
            return None  # fallback to default error handler
        feedback = self.id + ' ' + body
        #
        #
        #    {
        #      "error": {
        #        {
        #          "reason": "Bad Request",
        #          "message": "Order is not cancellable"
        #        }
        #      }
        #    }
        #
        errorResponse = self.safe_dict(response, 'error')
        errorCode = self.safe_string(errorResponse, 'reason')
        if errorCode is not None:
            errorMessage = self.safe_string(errorResponse, 'message')
            self.throw_exactly_matched_exception(self.exceptions['exact'], errorCode, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], errorMessage, feedback)
            raise ExchangeError(feedback)
        # errors = self.safe_list(response, 'errors')
        # if errors is not None:
        #     if isinstance(errors, list):
        #         numErrors = len(errors)
        #         if numErrors > 0:
        #             errorCode = self.safe_string(errors[0], 'id')
        #             errorMessage = self.safe_string(errors[0], 'message')
        #             if errorCode is not None:
        #                 self.throw_exactly_matched_exception(self.exceptions['exact'], errorCode, feedback)
        #                 self.throw_broadly_matched_exception(self.exceptions['broad'], errorMessage, feedback)
        #                 raise new ExchangeError(feedback)
        #             }
        #         }
        #     }
        # }
        return None
