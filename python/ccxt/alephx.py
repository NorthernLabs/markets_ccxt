# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.abstract.alephx import ImplicitAPI
import hashlib
from ccxt.base.types import Int, Market, Num, Order, OrderSide, OrderType, Str, Trade
from typing import List
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import BadRequest
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import RateLimitExceeded
from ccxt.base.errors import InvalidNonce
from ccxt.base.decimal_to_precision import TICK_SIZE


class alephx(Exchange, ImplicitAPI):

    def describe(self):
        return self.deep_extend(super(alephx, self).describe(), {
            'id': 'alephx',
            'name': 'AlephX',
            'countries': ['CA'],
            'pro': True,
            'certified': False,
            # rate-limits: N/A
            'rateLimit': 1000,
            'version': 'v1',
            'userAgent': self.userAgents['chrome'],
            # 'headers': {
            #     'ZKX-VERSION': '2018-05-30',
            # },
            'has': {
                'CORS': True,
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'addMargin': False,
                'cancelOrder': True,
                'cancelOrders': True,
                'closeAllPositions': False,
                'closePosition': True,
                'createConvertTrade': True,
                'createDepositAddress': True,
                'createLimitBuyOrder': True,
                'createLimitSellOrder': True,
                'createMarketBuyOrder': True,
                'createMarketBuyOrderWithCost': True,
                'createMarketOrderWithCost': False,
                'createMarketSellOrder': True,
                'createMarketSellOrderWithCost': False,
                'createOrder': True,
                'createPostOnlyOrder': True,
                'createReduceOnlyOrder': False,
                'createStopLimitOrder': True,
                'createStopMarketOrder': False,
                'createStopOrder': True,
                'deposit': True,
                'editOrder': True,
                'fetchAccounts': True,
                'fetchBalance': True,
                'fetchBidsAsks': True,
                'fetchBorrowRateHistories': False,
                'fetchBorrowRateHistory': False,
                'fetchCanceledOrders': True,
                'fetchClosedOrders': True,
                'fetchConvertQuote': True,
                'fetchConvertTrade': True,
                'fetchConvertTradeHistory': False,
                'fetchCrossBorrowRate': False,
                'fetchCrossBorrowRates': False,
                'fetchCurrencies': True,
                'fetchDeposit': True,
                'fetchDepositAddress': 'emulated',
                'fetchDepositAddresses': False,
                'fetchDepositAddressesByNetwork': True,
                'fetchDeposits': True,
                'fetchFundingHistory': False,
                'fetchFundingRate': False,
                'fetchFundingRateHistory': False,
                'fetchFundingRates': False,
                'fetchIndexOHLCV': False,
                'fetchIsolatedBorrowRate': False,
                'fetchIsolatedBorrowRates': False,
                'fetchL2OrderBook': False,
                'fetchLedger': True,
                'fetchLeverage': False,
                'fetchLeverageTiers': False,
                'fetchMarginMode': False,
                'fetchMarkets': True,
                'fetchMarkOHLCV': False,
                'fetchMyBuys': True,
                'fetchMySells': True,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenInterestHistory': False,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchPosition': True,
                'fetchPositionMode': False,
                'fetchPositions': True,
                'fetchPositionsRisk': False,
                'fetchPremiumIndexOHLCV': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchTrades': True,
                'fetchTradingFee': 'emulated',
                'fetchTradingFees': True,
                'fetchWithdrawals': True,
                'reduceMargin': False,
                'setLeverage': False,
                'setMarginMode': False,
                'setPositionMode': False,
                'withdraw': True,
            },
            'urls': {
                # 'logo': 'https://user-images.githubusercontent.com/1294454/40811661-b6eceae2-653a-11e8-829e-10bfadb078cf.jpg',
                'api': {
                    'rest': 'https://api.alephx.xyz',
                },
                'www': 'https://demo.alephx.xyz',
                # 'doc': [
                #     'https://developers.alephx.com/api/v2',
                #     'https://docs.cloud.alephx.com/advanced-trade/docs/welcome',
                # ],
                # 'fees': [
                #     'https://support.alephx.com/customer/portal/articles/2109597-buy-sell-bank-transfer-fees',
                #     'https://www.alephx.com/advanced-fees',
                # ],
                # 'referral': 'https://www.alephx.com/join/58cbe25a355148797479dbd2',
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
            },
            'api': {
                'v1': {
                    # 'public': {
                    # },
                    'private': {
                        'get': {
                            'orders': 0,
                            'orders/{id}': 0,
                            'trades': 0,
                        },
                        'post': {
                            'orders': 0,
                        },
                        'patch': {
                            'orders/{id}/cancel': 0,
                        },
                    },
                },
            },
            # 'fees': {
            # },
            # 'precisionMode': TICK_SIZE,
            # 'exceptions': {
            #     'exact': {
            #         'two_factor_required': AuthenticationError,  # 402 When sending money over 2fa limit
            #         'param_required': ExchangeError,  # 400 Missing parameter
            #         'validation_error': ExchangeError,  # 400 Unable to validate POST/PUT
            #         'invalid_request': ExchangeError,  # 400 Invalid request
            #         'personal_details_required': AuthenticationError,  # 400 User’s personal detail required to complete self request
            #         'identity_verification_required': AuthenticationError,  # 400 Identity verification is required to complete self request
            #         'jumio_verification_required': AuthenticationError,  # 400 Document verification is required to complete self request
            #         'jumio_face_match_verification_required': AuthenticationError,  # 400 Document verification including face match is required to complete self request
            #         'unverified_email': AuthenticationError,  # 400 User has not verified their email
            #         'authentication_error': AuthenticationError,  # 401 Invalid auth(generic)
            #         'invalid_authentication_method': AuthenticationError,  # 401 API access is blocked for deleted users.
            #         'invalid_token': AuthenticationError,  # 401 Invalid Oauth token
            #         'revoked_token': AuthenticationError,  # 401 Revoked Oauth token
            #         'expired_token': AuthenticationError,  # 401 Expired Oauth token
            #         'invalid_scope': AuthenticationError,  # 403 User hasn’t authenticated necessary scope
            #         'not_found': ExchangeError,  # 404 Resource not found
            #         'rate_limit_exceeded': RateLimitExceeded,  # 429 Rate limit exceeded
            #         'internal_server_error': ExchangeError,  # 500 Internal server error
            #         'UNSUPPORTED_ORDER_CONFIGURATION': BadRequest,
            #         'INSUFFICIENT_FUND': BadRequest,
            #         'PERMISSION_DENIED': PermissionDenied,
            #         'INVALID_ARGUMENT': BadRequest,
            #     },
            #     'broad': {
            #         'request timestamp expired': InvalidNonce,  # {"errors":[{"id":"authentication_error","message":"request timestamp expired"}]}
            #         'order with self orderID was not found': OrderNotFound,  # {"error":"unknown","error_details":"order with self orderID was not found","message":"order with self orderID was not found"}
            #     },
            # },
            # 'timeframes': {
            #     '1m': 'ONE_MINUTE',
            #     '5m': 'FIVE_MINUTE',
            #     '15m': 'FIFTEEN_MINUTE',
            #     '30m': 'THIRTY_MINUTE',
            #     '1h': 'ONE_HOUR',
            #     '2h': 'TWO_HOUR',
            #     '6h': 'SIX_HOUR',
            #     '1d': 'ONE_DAY',
            # },
            # 'commonCurrencies': {
            #     'CGLD': 'CELO',
            # },
            # 'options': {
            #     'usePrivate': False,
            #     'brokerId': 'ccxt',
            #     'stablePairs': ['BUSD-USD', 'CBETH-ETH', 'DAI-USD', 'GUSD-USD', 'GYEN-USD', 'PAX-USD', 'PAX-USDT', 'USDC-EUR', 'USDC-GBP', 'USDT-EUR', 'USDT-GBP', 'USDT-USD', 'USDT-USDC', 'WBTC-BTC'],
            #     'fetchCurrencies': {
            #         'expires': 5000,
            #     },
            #     'accounts': [
            #         'wallet',
            #         'fiat',
            #         # 'vault',
            #     ],
            #     'v3Accounts': [
            #         'ACCOUNT_TYPE_CRYPTO',
            #         'ACCOUNT_TYPE_FIAT',
            #     ],
            #     'networks': {
            #         'ERC20': 'ethereum',
            #         'XLM': 'stellar',
            #     },
            #     'createMarketBuyOrderRequiresPrice': True,
            #     'advanced': True,  # set to True if using any v3 endpoints from the advanced trade API
            #     'fetchMarkets': 'fetchMarketsV3',  # 'fetchMarketsV3' or 'fetchMarketsV2'
            #     'fetchTicker': 'fetchTickerV3',  # 'fetchTickerV3' or 'fetchTickerV2'
            #     'fetchTickers': 'fetchTickersV3',  # 'fetchTickersV3' or 'fetchTickersV2'
            #     'fetchAccounts': 'fetchAccountsV3',  # 'fetchAccountsV3' or 'fetchAccountsV2'
            #     'fetchBalance': 'v2PrivateGetAccounts',  # 'v2PrivateGetAccounts' or 'v3PrivateGetBrokerageAccounts'
            #     'fetchTime': 'v2PublicGetTime',  # 'v2PublicGetTime' or 'v3PublicGetBrokerageTime'
            #     'user_native_currency': 'USD',  # needed to get fees for v3
            # },
        })

    def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}):
        """
        create an order
        :see: POST https://api.alephx.xyz/api/v1/orders
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much you want to trade in units of the base currency, quote currency for 'market' 'buy' orders
        :param float [price]: the price to fulfill the order, in units of the quote currency, ignored in market orders
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.timeInForce]: 'gtc'
        :param str [params.idempotencyKey]: uuid for idempotency key
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        request: dict = {
            'pair': symbol,
            'type': side,
            'ordertype': type,
            'volume': amount,
        }
        orderRequest = self.order_request('createOrder', symbol, type, request, amount, price, params)
        response = self.v1PrivatePostOrders(self.extend(orderRequest[0], orderRequest[1]))
        #
        # successful order
        #
        #
        # failed order
        #
        #
        errorResponse = self.safe_dict(response, 'error')
        if errorResponse is not None:
            errorReason = self.safe_string(errorResponse, 'reason')
            errorMessage = self.safe_string(errorResponse, 'message')
            raise ExchangeError(errorReason + '' + errorMessage)
        return self.parse_order(response)

    def order_request(self, method: str, symbol: str, type: str, request: dict, amount: Num, price: Num = None, params={}):
        clientOrderId = self.safe_string_2(params, 'idempotencyKey', 'idempotencykey')
        if clientOrderId is not None:
            request['idempotencyKey'] = clientOrderId
        isLimitOrder = type == 'limit'
        if isLimitOrder:
            request['price'] = price
        timeInForce = self.safe_string_2(params, 'timeInForce', 'gtc')
        if timeInForce is not None:
            request['timeinforce'] = timeInForce
        params = self.omit(params, ['timeInForce', 'idempotencyKey'])
        return [request, params]

    def parse_order(self, order: dict, market: Market = None) -> Order:
        #
        # createOrder
        #
        #     {
        #         "order_id": "52cfe5e2-0b29-4c19-a245-a6a773de5030",
        #         "status": "pending_new"
        #     }
        #
        # cancelOrder
        #
        #     {
        #     }
        #
        # fetchOrder, fetchOrders
        #
        #     {
        #     }
        #
        createdDateTime = self.safe_string(order, 'inserted_at')
        filledDateTime = self.safe_string(order, 'filled_at')
        return self.safe_order({
            'info': order,
            'id': self.safe_string(order, 'order_id') or self.safe_string(order, 'id'),
            'clientOrderId': self.safe_string(order, 'idempotency_key'),
            'timestamp': self.parse8601(createdDateTime) if createdDateTime else None,
            'datetime': createdDateTime,
            'lastTradeTimestamp': self.parse8601(filledDateTime) if filledDateTime else None,
            'symbol': self.safe_string(order, 'symbol'),
            'type': self.safe_string(order, 'type'),
            'timeInForce': self.safe_string(order, 'time_in_force'),
            'postOnly': True,
            'side': self.safe_string_lower(order, 'side'),
            'price': self.safe_string(order, 'price'),
            'stopPrice': None,
            'triggerPrice': None,
            'amount': self.safe_string(order, 'base_quantity'),
            'filled': self.safe_string(order, 'filled_quantity'),
            'remaining': self.safe_string(order, 'remained_quantity'),
            'cost': None,
            'average': self.safe_string(order, 'average_filled_price'),
            'status': self.safe_string(order, 'status'),
            'fee': {
                'cost': self.safe_string(order, 'cumulative_fee'),
                'currency': self.safe_string(order, 'fee_asset'),
            },
            'trades': None,
        }, market)

    def cancel_order(self, id: str, symbol: Str = None, params={}):
        """
        cancels an open order
        :see: PATCH https://api.alephx.xyz/api/v1/orders/{order_id}/cancel
        :param str id: order id
        :param str symbol: not used by alephx cancelOrder()
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        request: dict = {
            'id': id,  # order id
        }
        response = self.v1PrivatePatchOrdersIdCancel(self.extend(request, params))
        errorResponse = self.safe_dict(response, 'error')
        if errorResponse is not None:
            errorReason = self.safe_string(errorResponse, 'reason')
            errorMessage = self.safe_string(errorResponse, 'message')
            if errorReason == 'Not Found':
                raise OrderNotFound(self.id + ' cancelOrder() error ' + errorReason)
            elif errorReason == 'Bad Request':
                raise BadRequest(self.id + ' cancelOrder() error ' + errorReason + ' ' + errorMessage)
            else:
                raise ExchangeError(errorReason + '' + errorMessage)
        return self.parse_order(response)

    def fetch_order(self, id: str, symbol: Str = None, params={}):
        """
        fetches information on an order made by the user
        :see: GET https://api.alephx.xyz/api/v1/orders/{order_id}
        :param str id: the order id
        :param str symbol: unified market symbol that the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        request: dict = {
            'id': id,  # order id
        }
        response = self.v1PrivateGetOrdersId(self.extend(request, params))
        errorResponse = self.safe_dict(response, 'error')
        if errorResponse is not None:
            errorReason = self.safe_string(errorResponse, 'reason')
            if errorReason == 'Not Found':
                raise OrderNotFound(self.id + ' fetchOrder() error ' + errorReason)
        return self.parse_order(response)

    def fetch_orders(self, symbol: Str = None, since: Int = None, limit: Int = 100, params={}) -> List[Order]:
        """
        fetches information on multiple orders made by the user
        :see: GET https://api.alephx.xyz/api/v1/orders/
        :param str symbol: unified market symbol that the orders were made in
        :param int [since]: the earliest time in ms to fetch orders
        :param int [limit]: the maximum number of order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.until]: the latest time in ms to fetch trades for
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :returns Order[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        request = {}
        response = self.v1PrivateGetOrders(self.extend(request, params))
        #
        #
        market = None
        return self.parse_orders(response, market, since, limit)

    def fetch_my_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        """
        fetch all trades made by the user
        :see: GET https://api.alephx.xyz/api/v1/trades
        :param str symbol: unified market symbol of the trades
        :param int [since]: timestamp in ms of the earliest order, default is None
        :param int [limit]: the maximum number of trade structures to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param int [params.until]: the latest time in ms to fetch trades for
        :param boolean [params.paginate]: default False, when True will automatically paginate by calling self endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        :returns Trade[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        request = {}
        response = self.v1PrivateGetTrades(self.extend(request, params))
        #
        #
        market = None
        return self.parse_trades(response, market, since, limit)

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        # fetchTrades
        #
        #     {
        #     }
        #
        createdDateTime = self.safe_string(trade, 'inserted_at')
        traderSide = self.safe_string(trade, 'side')
        traderOrderId = traderSide == self.safe_string(trade, 'buy_order_id') if 'buy' else self.safe_string(trade, 'sell_order_id')
        return self.safe_trade({
            'id': self.safe_string(trade, 'id'),
            'order': traderOrderId,
            'info': trade,
            'timestamp': self.parse8601(createdDateTime),
            'datetime': createdDateTime,
            'symbol': self.safe_string(trade, 'symbol'),
            'type': None,
            'side': traderSide,
            'takerOrMaker': None,
            'price': self.safe_string(trade, 'price'),
            'amount': self.safe_string(trade, 'base_quantity'),
            'cost': self.safe_string(trade, 'quote_quantity'),
            'fee': {
                'cost': self.safe_string(trade, 'fee'),
                'currency': self.safe_string(trade, 'fee_asset'),
            },
        }, market)

    def sign(self, path, api=[], method='GET', params={}, headers=None, body=None):
        version = api[0]
        signed = api[1] == 'private'
        fullPath = '/api/' + version + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        savedPath = fullPath
        if method == 'GET':
            if query:
                fullPath += '?' + self.urlencode_with_array_repeat(query)
        url = self.urls['api']['rest'] + fullPath
        if signed:
            authorization = self.safe_string(self.headers, 'Authorization')
            authorizationString = None
            if authorization is not None:
                authorizationString = authorization
            elif self.token and not self.check_required_credentials(False):
                authorizationString = 'Bearer ' + self.token
            else:
                self.check_required_credentials()
                # doesn't need payload in the signature. inside url is enough
                timestampString = str(self.seconds())
                auth = timestampString + method + savedPath
                signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256)
                headers = {
                    'ZKX-ACCESS-KEY': self.apiKey,
                    'ZKX-ACCESS-SIGN': signature,
                    'ZKX-ACCESS-TIMESTAMP': timestampString,
                    'Content-Type': 'application/json',
                }
            if authorizationString is not None:
                headers = {
                    'Authorization': authorizationString,
                    'Content-Type': 'application/json',
                }
                if method != 'GET':
                    if query:
                        body = self.json(query)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code: int, reason: str, url: str, method: str, headers: dict, body: str, response, requestHeaders, requestBody):
        if response is None:
            return None  # fallback to default error handler
        feedback = self.id + ' ' + body
        #
        #
        #    {
        #      "error": {
        #        {
        #          "reason": "Bad Request",
        #          "message": "Order is not cancellable"
        #        }
        #      }
        #    }
        #
        errorResponse = self.safe_dict(response, 'error')
        errorCode = self.safe_string(errorResponse, 'reason')
        if errorCode is not None:
            errorMessage = self.safe_string(errorResponse, 'message')
            self.throw_exactly_matched_exception(self.exceptions['exact'], errorCode, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], errorMessage, feedback)
            raise ExchangeError(feedback)
        # errors = self.safe_list(response, 'errors')
        # if errors is not None:
        #     if isinstance(errors, list):
        #         numErrors = len(errors)
        #         if numErrors > 0:
        #             errorCode = self.safe_string(errors[0], 'id')
        #             errorMessage = self.safe_string(errors[0], 'message')
        #             if errorCode is not None:
        #                 self.throw_exactly_matched_exception(self.exceptions['exact'], errorCode, feedback)
        #                 self.throw_broadly_matched_exception(self.exceptions['broad'], errorMessage, feedback)
        #                 raise new ExchangeError(feedback)
        #             }
        #         }
        #     }
        # }
        return None
